import numpy as np
import pandas as pd
import os

# 创建输出目录
OUTPUT_DIR = "Yearly_Schedules"
if not os.path.exists(OUTPUT_DIR):
    os.makedirs(OUTPUT_DIR)

class LunarWaterManager:
    def __init__(self):
        # 1. 基础参数
        self.population = 100000 
        self.demand_per_capita_kg = 9.68
        self.recycle_rate = 0.98
        
        # 2. 需求计算
        self.daily_demand_total_kg = self.population * self.demand_per_capita_kg
        self.daily_demand_total_tons = self.daily_demand_total_kg / 1000.0
        self.daily_net_import_needed = self.daily_demand_total_tons * (1 - self.recycle_rate) # 约 19.36吨/天

        # 3. 运输参数
        self.elev_max_capacity = 200.0
        self.rocket_capacity_per_launch = 50.0
    
        # 4. 库存参数
        self.storage_max = 700
        self.storage_initial = 600.0 # 初始库存
        
        # 策略阈值
        self.THRESHOLD_GREEN = 600.0
        self.THRESHOLD_RED = 400.0

    # ==============================================================
    #  核心物理函数 (可在后续调整为任意经验函数)
    # ==============================================================

    def get_p1_fail(self, t_year):
        """
        P1(y): 太空电梯不可用概率 (随年份增加而老化)
        当前逻辑: Logistic 增长
        """
        # 您可以在这里修改任意公式
        return 1.0 / (1.0 + np.exp(-(0.07 * t_year - 2.16)))

    def get_p2_efficiency(self, t_year):
        """
        P2(y): 电梯正常运行时的效率均值
        当前逻辑: 常数 0.88 (未来可改为随年份降低或提高)
        """
        # 示例: return 0.88 - 0.001 * t_year (每年老化)
        return 0.88

    def get_p3_fail(self, t_year):
        """
        P3(y): 火箭发射失败率
        当前逻辑: 常数 0.05 (未来可改为随技术成熟降低)
        """
        # 示例: return 0.05 * np.exp(-0.05 * t_year) (随时间技术成熟)
        return 0.05

    # ==============================================================

    def generate_all_years_schedule(self, total_years=20):
        current_storage = self.storage_initial
        all_logs = []
        
        print(f"正在生成 {total_years} 年的详细运营表...")
        
        for year in range(total_years):
            t_year = year # 假设从第0年(或者说第1年，t=0)开始
            
            # --- 调用封装好的物理函数获取当年参数 ---
            p1_fail = self.get_p1_fail(t_year)
            p2_eff  = self.get_p2_efficiency(t_year)
            p3_fail = self.get_p3_fail(t_year)
            
            yearly_log = []
            
            # --- 增加：状态机变量 ---
            repair_counter = 0 # 记录当前还需要修几天
            
            # 假设平均每年坏 N 次，每次平均修 M 天
            # P1 (不可用率) ≈ (N * M) / 365
            # 如果 P1=0.1, MTTR=7天, 则 N ≈ 5次
            MTTR_DAYS = 20 # 设定每次大修平均 30 天！
            
            # --- 日常循环 ---
            for day in range(1, 366):
                # 1. 早间决策
                status_code = "NORMAL"
                plan_elev = 0.0
                plan_rocket = 0.0
                
                # --- 状态机故障模拟 ---
                is_elevator_available = True
                
                if repair_counter > 0:
                    is_elevator_available = False
                    repair_counter -= 1 
                else:
                    # 将年均 P1 分摊到每一天触发故障的概率
                    if p1_fail > 0: # 防止 p1 为 0 时出错
                         prob_breakdown = p1_fail / MTTR_DAYS
                    else:
                         prob_breakdown = 0
                    
                    if np.random.random() < prob_breakdown:
                        is_elevator_available = False
                        repair_counter = max(1, np.random.poisson(MTTR_DAYS)) - 1
                
                # --- P-Control 控制器 ---
                TARGET_STORAGE = 600.0
                Kp = 0.15 
                
                error = TARGET_STORAGE - current_storage
                adjustment = error * Kp
                
                # 使用当年的物理参数进行计算
                expected_efficiency = (1 - p1_fail) * p2_eff 
                if expected_efficiency < 0.1: expected_efficiency = 0.1
                
                ideal_plan = (self.daily_net_import_needed + adjustment) / expected_efficiency
                ideal_plan = max(0, ideal_plan)
                
                # 分配逻辑
                status_code = "BALANCE"
                if is_elevator_available:
                    plan_elev = min(ideal_plan, self.elev_max_capacity)
                    remain_need = ideal_plan - plan_elev
                    # 电梯好的时候，通常不需要火箭，除非 remains 很大
                    if remain_need > 0:
                        # [修改] 删除黄区机制，改为低于绿区(目标值)即允许火箭补充
                        if current_storage < self.THRESHOLD_GREEN:
                             plan_rocket = remain_need / (1 - p3_fail)
                        else:
                             plan_rocket = 0
                    else:
                        plan_rocket = 0
                
                # [保留] 双重保险：如果库存还是跌破红线了(可能因为火箭也炸了)，强制最大化补给
                if current_storage < self.THRESHOLD_RED:
                    status_code = "EMERGENCY"
                    if remain_need > 0:
                        plan_rocket = remain_need / (1 - p3_fail) * 1.1 
                
                # [修改] 删除黄区(RECOVERY)判断，直接进入稳定状态判断
                else:
                    if abs(error) < 500: status_code = "STABLE"
                    pass
                
                # 2. 物理执行
                actual_elev_arrival = 0
                if is_elevator_available and plan_elev > 0:
                    # 使用当年的 p2_eff
                    actual_elev_arrival = plan_elev * np.random.normal(p2_eff, 0.02)
                    actual_elev_arrival = max(0, actual_elev_arrival)
                
                actual_rocket_arrival = 0
                if plan_rocket > 0:
                    n_launches = int(np.ceil(plan_rocket / self.rocket_capacity_per_launch))
                    # 使用当年的 p3_fail
                    successes = np.random.binomial(n_launches, 1 - p3_fail)
                    actual_rocket_arrival = successes * self.rocket_capacity_per_launch
                
                total_arrival = actual_elev_arrival + actual_rocket_arrival
                
                # 3. 晚间结算
                actual_demand = np.random.normal(self.daily_net_import_needed, self.daily_net_import_needed * 0.05)
                storage_start = current_storage
                current_storage = storage_start + total_arrival - actual_demand
                
                if current_storage > self.storage_max: current_storage = self.storage_max
                if current_storage < 0: current_storage = 0
                
                record = {
                    "Year": year + 1,
                    "Day": day,
                    "Global_Day": year * 365 + day,
                    "Status": status_code,
                    "Start_Storage": round(storage_start, 2),
                    "Is_Elev_OK": int(is_elevator_available),
                    "Plan_Elev": round(plan_elev, 2),
                    "Plan_Rocket": round(plan_rocket, 2),
                    "Actual_Arrival": round(total_arrival, 2),
                    "Actual_Demand": round(actual_demand, 2),
                    "End_Storage": round(current_storage, 2)
                }
                yearly_log.append(record)
                all_logs.append(record)
            
            df_year = pd.DataFrame(yearly_log)
            filename = f"{OUTPUT_DIR}/Year_{year+1}_Detailed_Schedule.csv"
            df_year.to_csv(filename, index=False)
            print(f"  -> 已保存 ({p1_fail:.4f}, {p2_eff:.2f}, {p3_fail:.2f}): {filename}")
            
        return pd.DataFrame(all_logs)

if __name__ == "__main__":
    manager = LunarWaterManager()
    df_all = manager.generate_all_years_schedule(total_years=20)
    df_all.to_csv(f"{OUTPUT_DIR}/All_Years_Summary.csv", index=False)
    print("全部完成！总表已保存为 All_Years_Summary.csv")
